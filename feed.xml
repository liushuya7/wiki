<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Joshua Personal Notes</title>
    <link href="https://liushuya7.github.io/wiki/feed.xml" rel="self" />
    <link href="https://liushuya7.github.io/wiki" />
    <updated>2022-12-13T20:37:08-05:00</updated>
    <author>
        <name>Joshua Liu</name>
    </author>
    <id>https://liushuya7.github.io/wiki</id>

    <entry>
        <title>Biblical Hebrew</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/biblical-hebrew/"/>
        <id>https://liushuya7.github.io/wiki/biblical-hebrew/</id>
            <category term="Biblical Hebrew"/>

        <updated>2022-12-13T20:37:08-05:00</updated>
            <summary></summary>
        <content></content>
    </entry>
    <entry>
        <title>Genesis 1 in Hebrew</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/genesis-1-in-hebrew/"/>
        <id>https://liushuya7.github.io/wiki/genesis-1-in-hebrew/</id>
            <category term="Biblical Hebrew"/>

        <updated>2022-12-13T20:36:39-05:00</updated>
            <summary>
                <![CDATA[
                    Ch 1 v1-2 v3-5 v6-8 v9-10 v11-13
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="ch-1">Ch 1</h2>
<h3 id="v1-2">v1-2</h3>
<div class="post__iframe"><iframe loading="lazy" width="560" height="315" src="https://www.youtube.com/embed/D1ge6-3R_8s?clip=Ugkx8dfmHWYH3b9rXLBE2EeSQ1H0dDy-WMrB&amp;clipt=EIhUGOW2Ag" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

<h3 id="v3-5">v3-5</h3>
<div class="post__iframe"><iframe loading="lazy" width="560" height="315" src="https://www.youtube.com/embed/D1ge6-3R_8s?clip=Ugkxo5ftw6fR_bvjSFwk-apCU0cpJyk_Lk7j&amp;clipt=ELLLAhjS_wQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

<h3 id="v6-8">v6-8</h3>
<div class="post__iframe"><iframe loading="lazy" width="560" height="315" src="https://www.youtube.com/embed/D1ge6-3R_8s?clip=Ugkx2r36Cpbtb50fRk3vTDjCoiTy0e__hE5r&amp;clipt=ENCIBRiw8gc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

<h3 id="v9-10">v9-10</h3>
<div class="post__iframe"><iframe loading="lazy" width="560" height="315" src="https://www.youtube.com/embed/D1ge6-3R_8s?clip=UgkxwC5R_uErhDlMEWmrnnJeRbj9GpgZH7hZ&amp;clipt=EOuECBjt9gk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

<h3 id="v11-13">v11-13</h3>
<div class="post__iframe"><iframe loading="lazy" width="560" height="315" src="https://www.youtube.com/embed/D1ge6-3R_8s?clip=Ugkxh0VPlujjILpTpYViOVLe5P860sSEo7Mt&amp;clipt=ELyKChiMvg0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

            ]]>
        </content>
    </entry>
    <entry>
        <title>PyVista/Trimesh</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/pyvistatrimesh/"/>
        <id>https://liushuya7.github.io/wiki/pyvistatrimesh/</id>
            <category term="Python"/>

        <updated>2022-12-13T15:28:56-05:00</updated>
            <summary>
                <![CDATA[
                    Conversion Pyvista to Trimesh Convert Pyvista 1-D face array to Trimesh faces def pyvistaToTrimeshFaces(cells): faces = [] idx = 0 while idx &lt; len(cells): curr_cell_count&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="conversion">Conversion</h2>
<h3 id="pyvista-to-trimesh">Pyvista to Trimesh</h3>
<p>Convert Pyvista 1-D face array to Trimesh faces</p>
<pre><code class="language-py">def pyvistaToTrimeshFaces(cells):
    faces = []
    idx = 0
    while idx &lt; len(cells):
      curr_cell_count = cells[idx]
      curr_faces = cells[idx+1:idx+curr_cell_count+1]
      faces.append(curr_faces)
      idx += curr_cell_count+1
    return np.array(faces)
</code></pre>
<p>Reference: <a href="https://github.com/AbrarAnwar/cross_section_rl/blob/ffd9f6eb2c53fdceca7be916c030a853cad2b4e0/utils.py#L68">AbrarAnwar/cross_section_rl/utils.py</a></p>
<h3 id="meshlab-to-pyvista">Meshlab to Pyvista</h3>
<pre><code class="language-py">import numpy as np
import pyvista as pv

def meshlab2pv(mmesh):
    &#39;&#39;&#39;
    Convert meshlab mesh to PyVista polydata
    &#39;&#39;&#39;
    mpoints, mcells = mmesh.vertex_matrix(), mmesh.face_matrix()

    if len(mcells):
        # convert the faces into PolyData format
        mfaces = []
        for cell in mcells:
            face = np.hstack((len(cell), cell))
            mfaces.extend(face.tolist())
        mfaces = np.array(mfaces)
        polydata = pv.PolyData(mpoints, np.hstack(mfaces))
    else:
        polydata = pv.PolyData(mpoints, None)

    return polydata

if __name__ == &#39;__main__&#39;:
    import pymeshlab as pm
    
    ms = pm.MeshSet()
    ms.load_project(&#39;data/test.mlp&#39;)

    print(ms.print_status())

    meshes = []
    plotter = pv.Plotter()

    for i in range(ms.number_meshes()):
        mesh_pv = meshlab2pv(ms.mesh(i))
        meshes.append(mesh_pv)
        plotter.add_mesh(mesh_pv)

    plotter.add_mesh_slice_orthogonal(meshes[0])

    plotter.show()
</code></pre>
<h2 id="qt-gui">Qt GUI</h2>
<p>Pyvistaqt Example:</p>
<pre><code class="language-py">import sys

from PyQt5 import Qt, QtCore

import pyvista as pv
from pyvistaqt import QtInteractor

# from pyvista import themes
# pv.set_plot_theme(themes.DarkTheme())


class MainWidget(Qt.QWidget):

    def __init__(self, parent=None, show=True):
        super(MainWidget, self).__init__()

        self.test_button = Qt.QPushButton(&quot;Open&quot;)
        self.test_button.clicked.connect(self.test_button_event)

        self.frame = Qt.QFrame()
        self.plotter = QtInteractor(self.frame)
        vlayout = Qt.QVBoxLayout()
        vlayout.addWidget(self.plotter.interactor)
        hlayout = Qt.QHBoxLayout()
        hlayout.addWidget(self.test_button)
        vlayout.addLayout(hlayout)
        self.setLayout(vlayout)

        self.setWindowTitle(&quot;Test Qt Window&quot;)
        self.setGeometry(550, 200, 800, 600)

        # Enable dragging and dropping onto the GUI
        self.setAcceptDrops(True)

        self.plotter.show_axes()
        self.mesh = None

        if show:
            self.show()

    # The following three methods set up dragging and dropping for the app
    def dragEnterEvent(self, e):
        if e.mimeData().hasUrls:
            e.accept()
        else:
            e.ignore()

    def dragMoveEvent(self, e):
        if e.mimeData().hasUrls:
            e.accept()
        else:
            e.ignore()

    def dropEvent(self, e):
        &quot;&quot;&quot;
        Drop files directly onto the widget
        File locations are stored in fname
        :param e:
        :return:
        &quot;&quot;&quot;
        if e.mimeData().hasUrls:
            e.setDropAction(QtCore.Qt.CopyAction)
            e.accept()
            # Workaround for OSx dragging and dropping
            for url in e.mimeData().urls():
                fname = str(url.toLocalFile())
            self.fname = fname
            self.load_mesh()
        else:
            e.ignore()

    def test_button_event(self):
        &quot;&quot;&quot;
        Open a mesh file
        &quot;&quot;&quot;
        self.fname, _ = Qt.QFileDialog.getOpenFileName(self, &#39;Open file&#39;,&#39;&#39;,&quot;(*.ply) ;; (*.stl)&quot;)
        self.load_mesh()

    def load_mesh(self):
        self.mesh = pv.read(self.fname)
        self.plotter.clear()
        self.plotter.add_mesh(self.mesh, show_edges=True)
        self.plotter.reset_camera()

    def save_mesh(self):
        &quot;&quot;&quot;
        Save mesh
        &quot;&quot;&quot;
        self.fname, f_filter = Qt.QFileDialog.getSaveFileName(self, &#39;Save file&#39;, self.fname, &quot;(*.ply) ;; (*.stl)&quot;)
        pv.save_meshio(self.fname, self.mesh, file_format=f_filter.strip(&#39;(*.)&#39;))
        # close the window
        self.close()


if __name__ == &#39;__main__&#39;:
    app = Qt.QApplication(sys.argv)
    window = MainWidget()
    sys.exit(app.exec_())
</code></pre>
<p><a href="https://gist.github.com/hichamjanati/6668d91848283c31ac18d801552fb582">Optimization visualization with pyvista</a>:</p>
<pre><code class="language-py">import pyvista as pv
import numpy as np

make_gif = True

# increase n_points for a higher resolution
n_points = 100
xmin, xmax = -1.2, 1.2
bounds = 1.25 * np.array([xmin, xmax, xmin, xmax, 0., 0.])
x = np.linspace(xmin, xmax, n_points)
y = np.linspace(xmin, xmax, n_points)
x, y = np.meshgrid(x, y)
coords = np.array(list(zip(x.flatten(), y.flatten())))

g = x ** 4 + y ** 4
g = g.flatten()
constraint_mask = g &lt;= 1


def func(x, y):
    return x ** 3 - y ** 3 + 2


f = func(x, y)
f = f.flatten()

domain_coords = np.zeros((n_points ** 2, 3))
domain_coords[:, :2] = coords
domain = pv.PolyData(domain_coords)
domain = domain.delaunay_2d()
domain_in, _ = domain.remove_points(~constraint_mask)
domain_out, _ = domain.remove_points(constraint_mask)

minimizer_array = np.array([- 0.5 ** 0.25, 0.5 ** 0.25, 0.])
value_array = minimizer_array + np.array([0., 0., func(*minimizer_array[:2])])
minimizer = pv.PolyData(minimizer_array)
dashed = pv.Spline(np.vstack((minimizer_array, value_array)), n_points=20)

cone_direction = np.array([-1., 1., 0.])
cone = pv.Cone(minimizer_array, cone_direction, angle=60, height=20)
cone.points[:, 2] = 0
cone.points *= 1 / (4 * 20) ** 0.5

surface_data = np.zeros((n_points ** 2, 3))
surface_data[:, :2] = coords
surface_data[:, 2] = f
surface = pv.PolyData(surface_data)
surface = pv.PolyData(surface)
surface = surface.delaunay_2d()
surface_in, _ = surface.remove_points(~constraint_mask)
surface_out, _ = surface.remove_points(constraint_mask)

constraint_title = pv.Text3D(&quot;Constraint set K&quot;, depth=0.2)
constraint_title.points -= constraint_title.points.mean(0)[None, :]
constraint_title.points *= \
    1.75 / (constraint_title.points.max() - constraint_title.points.min())
constraint_title.rotate_z(90)

text3d = pv.Text3D(&quot;Minimizer x&quot;, depth=0.2)
text3d.points -= text3d.points.mean(0)[None, :]
text3d.points /= text3d.points.max() - text3d.points.min()
text3d.rotate_z(90)
text3d.rotate_y(90)
text3d.points += 1.75 * minimizer_array

tangeant = pv.Text3D(&quot;Tangeant cone at x&quot;, depth=0.2)
tangeant.points -= tangeant.points.mean(0)[None, :]
tangeant.points *= 1.75 / (tangeant.points.max() - tangeant.points.min())
tangeant.rotate_z(90)
tangeant.rotate_x(180)
tangeant.rotate_y(90)
tangeant.points += np.array([-1.5, -1.5, 0])

plotter = pv.Plotter()
plotter.add_mesh(domain_out, color=&quot;gray&quot;, opacity=0.2)
plotter.add_mesh(domain_in, color=&quot;black&quot;)
plotter.add_mesh(surface_in, scalars=f[constraint_mask], cmap=&quot;hot&quot;)
plotter.add_mesh(surface_out, cmap=&quot;Greys&quot;, opacity=0.2)
plotter.add_mesh(cone, color=&quot;blue&quot;, opacity=0.3)
plotter.add_mesh(minimizer, color=&quot;red&quot;, render_points_as_spheres=True,
                 point_size=15)
plotter.add_mesh(dashed, color=&quot;red&quot;)
plotter.add_mesh(text3d, color=&quot;red&quot;)
plotter.add_mesh(tangeant, color=&quot;black&quot;)
plotter.add_mesh(constraint_title, color=&quot;white&quot;)
plotter.background_color = &quot;white&quot;
plotter.show_bounds(grid=&#39;front&#39;, location=&#39;outer&#39;,
                    show_zaxis=False, color=&quot;black&quot;,
                    bounds=bounds)

if make_gif:
    # when the window shows up, close it by pressing the q-Key NOT the quit
    # button
    plotter.show(auto_close=False)

    path = plotter.generate_orbital_path(3., n_points=200,
                                         shift=1.75 * domain_out.length)
    plotter.open_movie(&#39;orbit.mp4&#39;)
    plotter.orbit_on_path(path, write_frames=True)
    plotter.close()
else:
    plotter.show()
</code></pre>
<p><a href="https://gist.github.com/dgobbi/bfdb149e38777f25d0891c1b883858e2">Simple QVTKRenderWindowInteractor example in Python</a>:</p>
<pre><code class="language-py"># coding=utf-8

import sys

from vtkmodules.vtkFiltersSources import vtkConeSource
from vtkmodules.vtkRenderingCore import vtkActor, vtkPolyDataMapper, vtkRenderer
# load implementations for rendering and interaction factory classes
import vtkmodules.vtkRenderingOpenGL2
import vtkmodules.vtkInteractionStyle

import QVTKRenderWindowInteractor as QVTK
QVTKRenderWindowInteractor = QVTK.QVTKRenderWindowInteractor

if QVTK.PyQtImpl == &#39;PySide6&#39;:
    from PySide6.QtCore import Qt
    from PySide6.QtWidgets import QApplication, QMainWindow
elif QVTK.PyQtImpl == &#39;PySide2&#39;:
    from PySide2.QtCore import Qt
    from PySide2.QtWidgets import QApplication, QMainWindow
else:
    from PySide.QtCore import Qt
    from PySide.QtGui import QApplication, QMainWindow


def QVTKRenderWidgetConeExample(argv):
    &quot;&quot;&quot;A simple example that uses the QVTKRenderWindowInteractor class.&quot;&quot;&quot;
    # every QT app needs an app
    app = QApplication([&#39;QVTKRenderWindowInteractor&#39;])

    window = QMainWindow()

    # create the widget
    widget = QVTKRenderWindowInteractor(window)
    window.setCentralWidget(widget)
    # if you don&#39;t want the &#39;q&#39; key to exit comment this.
    widget.AddObserver(&quot;ExitEvent&quot;, lambda o, e, a=app: a.quit())

    ren = vtkRenderer()
    widget.GetRenderWindow().AddRenderer(ren)

    cone = vtkConeSource()
    cone.SetResolution(8)

    coneMapper = vtkPolyDataMapper()
    coneMapper.SetInputConnection(cone.GetOutputPort())

    coneActor = vtkActor()
    coneActor.SetMapper(coneMapper)

    ren.AddActor(coneActor)

    # show the widget
    window.show()

    widget.Initialize()
    widget.Start()

    # start event processing
    # Source: https://doc.qt.io/qtforpython/porting_from2.html
    # &#39;exec_&#39; is deprecated and will be removed in the future.
    # Use &#39;exec&#39; instead.
    try:
        app.exec()
    except AttributeError:
        app.exec_()

if __name__ == &quot;__main__&quot;:
    QVTKRenderWidgetConeExample(sys.argv)
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Python</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/python/"/>
        <id>https://liushuya7.github.io/wiki/python/</id>
            <category term="Python"/>

        <updated>2022-12-13T15:30:48-05:00</updated>
            <summary>
                <![CDATA[
                    Collections PythonRobotics Comprehensive Python Cheatsheet Problem Solving with Python Scipy Lecture Notes Github: https://github.com/scipy-lectures/scipy-lecture-notes PythonTemplate Python Template is a Cookiecutter template for creating a python&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="collections">Collections</h2>
<ul>
<li><a href="https://github.com/AtsushiSakai/PythonRobotics">PythonRobotics</a></li>
<li><a href="https://github.com/gto76/python-cheatsheet">Comprehensive Python Cheatsheet</a></li>
<li><a href="https://problemsolvingwithpython.com/">Problem Solving with Python</a> </li>
<li><a href="https://scipy-lectures.org/">Scipy Lecture Notes</a><ul>
<li>Github: <a href="https://github.com/scipy-lectures/scipy-lecture-notes">https://github.com/scipy-lectures/scipy-lecture-notes</a></li>
</ul>
</li>
<li><a href="https://github.com/UCL/PythonTemplate">PythonTemplate</a><ul>
<li>Python Template is a Cookiecutter template for creating a python project</li>
</ul>
</li>
<li><a href="https://data36.com/linear-regression-in-python-numpy-polyfit/">Linear Regression in Python using numpy + polyfit (with code base)</a></li>
</ul>
<h3 id="libraries">Libraries</h3>
<ul>
<li><a href="https://pypi.org/project/cupoch/">cupoch</a> - Robotics with GPU computing</li>
<li><a href="https://github.com/neka-nat/kinpy">kinpy</a> -Simple kinematics calculation toolkit for robotics</li>
<li><a href="https://github.com/facebookresearch/pytorch3d">PyTorch3D</a> - provides efficient, reusable components for 3D Computer Vision research with <a href="https://pytorch.org/">PyTorch</a></li>
</ul>
<h3 id="tutorials">Tutorials</h3>
<ul>
<li><a href="https://notebook.community/">Jupyter Notebooks Gallery</a></li>
<li><a href="https://notebook.community/finnhacks42/opencv-play/templates/OpenCV%20tutorial">Learn OpenCV Jupyter notebook</a></li>
</ul>
<h2 id="quick-notes">Quick Notes</h2>
<h3 id="pip-install-from-a-git-repository"><code>**pip install**</code> From a Git Repository</h3>
<pre><code class="language-sh">python -m pip install git+https://github.com/django/django.git@main
</code></pre>
<h3 id="pip-install-from-a-local-dir"><code>**pip install**</code> From a local dir</h3>
<pre><code class="language-sh">pip install -e /path/to/package
</code></pre>
<ul>
<li><code>-e</code> installs the package in a way, that you can edit the package, but it requires that the package source stay in the same place (<code>/path/to/package</code> in this case) forever.</li>
</ul>
<h3 id="glob通配符获取文件列表"><code>**glob**</code>通配符获取文件列表</h3>
<pre><code class="language-sh">glob.glob(&quot;./*.jpg&quot;)
获取当前目录下的jpg文件列表
</code></pre>
<h3 id="__init__py的作用"><strong>__init__.py</strong>的作用</h3>
<p>参考链接 <a href="https://www.cnblogs.com/lands-ljk/p/5880483.html">https://www.cnblogs.com/lands-ljk/p/5880483.html</a></p>
<p><strong>__init__</strong>.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有__init__.py 文件。</p>
<p>通常__init__.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。</p>
<p>当导入模块时，解释器按照sys.path列表中的目录顺序来查找导入文件。</p>
<pre><code class="language-py">import sys
print(sys.path)
</code></pre>
<h2 id="other-tools">Other Tools</h2>
<ul>
<li><a href="https://stackoverflow.com/a/53070679">VScode Configure Python autoComplete extraPaths</a></li>
<li><a href="https://stackoverflow.com/a/64690321">Use Pylance for autoCompletion</a></li>
<li><a href="https://github.com/wenmin-wu/jupyter-tabnine">TabNine, Autocompletion for Jupyter Notebook</a></li>
</ul>
<h2 id="issues">Issues</h2>
<h3 id="编译ros提示缺少em模块"><strong>编译ros提示缺少em模块</strong></h3>
<pre><code class="language-bash">python3 -m pip install empy
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>C++ Learning Note</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/c-learning-note/"/>
        <id>https://liushuya7.github.io/wiki/c-learning-note/</id>
            <category term="C++"/>

        <updated>2022-12-13T13:45:40-05:00</updated>
            <summary>
                <![CDATA[
                    List #include &lt;list&gt; In C++ lists are ordered sequences of variables of the same type. To initialize them we have to specify which type are&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="list">List</h2>
<pre><code class="language-cpp">#include &lt;list&gt;
</code></pre>
<p>In C++ lists are ordered sequences of variables of the same type. To initialize them we have to specify which type are the variables inside it. For example, for a list of integer values:</p>
<pre><code class="language-cpp">list&lt;int&gt; numbers_list({1,10,100,1000});
</code></pre>
<p>And a list of string values:</p>
<pre><code class="language-cpp">list&lt;string&gt; vocals_list( {&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;} );
</code></pre>
<p>The inconvenience with lists in C++ is that they are not as easy to print as in other languages. In this case we need to loop over all the items in a list to print them one by one. For now, here’s an example of printing a list:</p>
<pre><code class="language-cpp">for (int val : numbers_list)             // Loop
    cout &lt;&lt; val &lt;&lt; &quot;  &quot;;                 // Print function

for (string val : vocals_list)           // Loop
    cout &lt;&lt; val &lt;&lt; &quot;  &quot;;                 // Print function
</code></pre>
<p>Lists are very useful, as they occupy a memory space that can be modified. They have builtin functions to, for example, add a new item in the beginning of the list, or at the end of it:</p>
<pre><code class="language-cpp">numbers_list.push_front(0);             //insert in the beginning
numbers_list.push_back(3000);           //insert in the end
</code></pre>
<p>The resulting list would be <code>0,1,10,100,1000,3000</code></p>
<p>Finally, we can also concatenate a list at the end of another, enlarging the first one and not deleting the second one, with the builtin function <code>insert()</code>:</p>
<pre><code class="language-cpp">list&lt;int&gt; new_list({5,50,500});

numbers_list.insert(numbers_list.end(),new_list.begin(),new_list.end());
</code></pre>
<p>Then the <code>numbers_list</code> will be modified as <code>0,1,10,100,1000,3000,5,50,500</code></p>
<h2 id="dictionaries"><strong>Dictionaries</strong></h2>
<pre><code class="language-cpp">#include &lt;map&gt;
</code></pre>
<p>A dictionary in C++ is called a <strong>map</strong>, and it is a container of values that are indexed by a key. This means that it stores two kinds of information: keys and values.</p>
<p>For example, if we want to store the names of a TV series characters and also in how many episodes they appear, we don’t need a list with the names and a list with the number of episodes, we just need a dictionary where the keys are the names and the values are the number of episodes: <code>{ &quot;Dolores&quot;: 30, &quot;Maeve&quot;: 27, &quot;Theresa&quot;:6, &quot;Clementine&quot;:11 }  { &quot;Dolores&quot;: 30, &quot;Maeve&quot;: 27, &quot;Theresa&quot;:6, &quot;Clementine&quot;:11 }</code> </p>
<p>To initialize it we need to call map, and specify the data types of the keys and values:</p>
<pre><code class="language-cpp">map&lt;string,int&gt; girls_dictionary;
</code></pre>
<p>Here we are creating a dictionary called <code>girls_dictionary</code>, where the keys are strings and the values are integers.</p>
<p>To insert data into this dictionary we can call each key and assign it a value, one by one:</p>
<pre><code class="language-cpp">girls_dictionary[&quot;Dolores&quot;] = 30;
girls_dictionary[&quot;Maeve&quot;] = 27;
girls_dictionary[&quot;Theresa&quot;] = 6;
girls_dictionary[&quot;Clementine&quot;] = 11;

for (auto item : girls_dictionary)
    cout &lt;&lt; item.first &lt;&lt; &quot; appears in &quot; &lt;&lt; item.second &lt;&lt; &quot; episodes\n&quot;;
</code></pre>
<p>Finally, we can print the items in the dictionary with a loop. When we print it this is not a list, the dictionary itself organizes the keys alphabetically.</p>
<pre><code class="language-cpp">map&lt;double, float&gt; x_t_dictionary;
x_t_dictionary[t_0] = x_0;
x_t_dictionary[t_1] = x_1;

// The functions ROS_INFO() and ROS_INFO_STREAM() essentially have the same purpose as &#39;cout&#39;
for (auto item : x_t_dictionary) {
  ROS_INFO_STREAM(&quot;Time &quot; &lt;&lt; item.first &lt;&lt; &quot;, position &quot; &lt;&lt; item.second
                          &lt;&lt; &quot; \n&quot;);
  }
</code></pre>
<h2 id="io-functions">I/O functions</h2>
<h3 id="print">Print</h3>
<ul>
<li>printf</li>
<li>cout</li>
</ul>
<h3 id="input">Input</h3>
<ul>
<li>cin</li>
<li>getline(cin, name)</li>
</ul>
<h2 id="arrays">Arrays</h2>
<pre><code class="language-cpp">int myarray[6];
int myarray[6] = {4,8,15,16,23,42};
int myarray[] = {4,8,15,16,23,42};
</code></pre>
<p>We can also print all the elements of an array with a for loop:</p>
<pre><code class="language-cpp">for (auto items : myarray) {
    cout &lt;&lt; items &lt;&lt; endl;
}
</code></pre>
<h2 id="pointers">Pointers</h2>
<pre><code class="language-cpp">int myvariable = 42;
</code></pre>
<p>We have already seen how to obtain the address of a variable using <code>&amp;</code>. The type of variable that can store this address of another variable is called a <strong>pointer</strong>. Pointers can be declared with the operator <code>*</code> , specifying the type of variable they will be pointing to:</p>
<pre><code class="language-cpp">int * mypointer;
</code></pre>
<p>If we want this pointer to store the address of our previous variable <code>myvariable</code>, we just need to give it the value of its address:</p>
<pre><code class="language-cpp">mypointer = &amp;myvariable;
cout &lt;&lt; mypointer &lt;&lt; endl;
</code></pre>
<p>This expression will print the previous address of <code>myvariable</code> we’ve seen in the first section:</p>
<pre><code class="language-text-plain">&gt; 177687
</code></pre>
<p>Now that the relationship between <code>myvariable</code> and <code>mypointer</code> is established, we can access the original value of <code>myvariable</code> just using its pointer:</p>
<pre><code class="language-cpp">cout &lt;&lt; *mypointer &lt;&lt; endl;
</code></pre>
<p>This will print the value stored in the memory with the address 177687:</p>
<pre><code class="language-text-plain">&gt; 42
</code></pre>
<p>We call this operation <strong>dereferencing</strong>, using the symbol <code>*</code>, and it is always followed by a name of a variable. Do not confuse the asterisk of declaring a pointer, which follows a data type, with this dereferencing operator!</p>
<ul>
<li>Why this is useful?<ul>
<li>We can first declare a variable, then assign a pointer to its address, and just manipulate this pointer to make changes.</li>
<li>Also, we cannot change the type of <code>myvariable</code> during a program, but a pointer can be assigned to another variable later in the same program.</li>
</ul>
</li>
</ul>
<h4 id="constants">Constants</h4>
<p>Pointers may also be used only to access values to read them, not to modify them. These will be pointers pointed to <strong>constant variables</strong>, which need to be specified when declaring the pointer.</p>
<p>For example, for an integer variable:</p>
<pre><code class="language-cpp">int variable = 10;
</code></pre>
<p>when declaring the pointer we need to specify that it points to a constant integer:</p>
<pre><code class="language-cpp">const int* pointer = &amp;variable;
</code></pre>
<p>We can read the value of the variable it is pointing to by <strong>dereferencing</strong>:</p>
<pre><code class="language-cpp">cout &lt;&lt; &quot;Value of variable: &quot; &lt;&lt; *pointer &lt;&lt; endl;
</code></pre>
<p>But we cannot change the value of the variable:</p>
<pre><code class="language-cpp">*pointer = 20; // INCORRECT!!!!
</code></pre>
<p>We can also create <strong>constant pointers</strong>, independently of them pointing to a constant variable or not. This kind of pointers need to specify the constant character right before the pointer’s name:</p>
<pre><code class="language-cpp">int* const pointer;
</code></pre>
<p>To make this even more trickier, here are all the possibilities we can have using constants:</p>
<pre><code class="language-cpp">int* pointer;                   // non-constant pointer to non-constant integer
const int* pointer;             // non-constant pointer to constant integer
int* const pointer;             // constant pointer to non-constant integer
const int* const pointer;       // constant pointer to constant integer
</code></pre>
<p>The final thing we need to learn is that in C++ functions CANNOT return arrays. It is just not possible. What they CAN do is return a pointer to an array. See how useful they are? Awesome.</p>
<p>In this exercise first we are going to show you a small piece of code of the <strong>RosbotClass</strong> we’ve been using all along:</p>
<pre><code class="language-cpp">float *RosbotClass::get_laser_full() {
  float *laser_range_pointer = laser_range.data();
  return laser_range_pointer;
}
</code></pre>
<p>This function called <strong>get_laser_full()</strong> is a function that returns a pointer (see the operator asterisk before the name of the class <code>**RosbotClass**</code>). What it does is take the values of a ROS vector called <strong>laser_range</strong> and assign them a pointer, then return this pointer.</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>C++ Code Snippet</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/c-code-snippet/"/>
        <id>https://liushuya7.github.io/wiki/c-code-snippet/</id>
            <category term="C++"/>

        <updated>2022-12-13T13:42:39-05:00</updated>
            <summary>
                <![CDATA[
                    Network Acquire Localhost IP Address #include &lt;arpa/inet.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;sys/types.h&gt; #include &lt;linux/if.h&gt; #include &lt;net/if_arp.h&gt; #include &lt;unistd.h&gt; #include &lt;linux/sockios.h&gt; #include &lt;linux/ethtool.h&gt; #include &lt;cstring&gt; #include &lt;cassert&gt;&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="network">Network</h2>
<h3 id="acquire-localhost-ip-address">Acquire Localhost IP Address</h3>
<pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;linux/if.h&gt;
#include &lt;net/if_arp.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linux/sockios.h&gt;
#include &lt;linux/ethtool.h&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

std::string ipAddressToString(uint32_t ipAddress)
{
    char buffer[INET_ADDRSTRLEN] = {0};
    uint32_t addr = htonl(ipAddress);
    return std::string(inet_ntop(AF_INET, &amp;addr, buffer, sizeof(buffer)));
}

int main(int argc, char *argv[]) {

    int fd = socket(AF_INET, SOCK_DGRAM, 0); 
    assert(fd &gt; 0); 

    struct ifconf ifc;
    struct ifreq *pifr;

    ifc.ifc_len = sizeof(struct ifreq) * 10; 
    ifc.ifc_buf = (char*) malloc(ifc.ifc_len);

    int err = ioctl(fd, SIOCGIFCONF, &amp;ifc);
    assert(err &gt;= 0); 

    int ifc_num = ifc.ifc_len / sizeof(struct ifreq);
    printf(&quot;Interfaces: %d\r\n&quot;, ifc_num);

    assert(ifc.ifc_buf != NULL);
    pifr = ifc.ifc_req;
    
    // Iterate trought all ifreq and save interface type, ip and netmask
    for (int i = 0;  i &lt; ifc_num; ++i)
    {       
        err = ioctl(fd, SIOCGIFADDR, &amp;pifr[i]);
        assert(err == 0); 
        uint32_t ipAddress = ntohl(reinterpret_cast&lt;struct sockaddr_in*&gt;(&amp;(pifr[i].ifr_addr))-&gt;sin_addr.s_addr);

        err = ioctl(fd, SIOCGIFNETMASK, &amp;pifr[i]);
        assert(err == 0); 
        uint32_t netmaskAddress = ntohl(reinterpret_cast&lt;struct sockaddr_in*&gt;(&amp;(pifr[i].ifr_netmask))-&gt;sin_addr.s_addr);

        err = ioctl(fd, SIOCGIFBRDADDR, &amp;pifr[i]);
        assert(err == 0); 
        uint32_t broadcastAddress = ntohl(reinterpret_cast&lt;struct sockaddr_in*&gt;(&amp;(pifr[i].ifr_broadaddr))-&gt;sin_addr.s_addr);

        printf(&quot;Network Interface: %s, IP=%s, Netmask=%s, Broadcast=%s\r\n&quot;, 
               pifr[i].ifr_name, 
               ipAddressToString(ipAddress).c_str(), 
               ipAddressToString(netmaskAddress).c_str(), 
               ipAddressToString(broadcastAddress).c_str());
    }   
}
</code></pre>
<h2 id="uncategorized">Uncategorized</h2>
<h3 id="22cpp二进制形式打开文件"><strong>22.cpp二进制形式打开文件</strong></h3>
<pre><code class="language-cpp">int begin, end;

  std::ifstream file(input_bmp_name, std::ios::in | std::ios::binary);
  if (!file) {
    LOG(FATAL) &lt;&lt; &quot;input file &quot; &lt;&lt; input_bmp_name &lt;&lt; &quot; not found&quot;;
    exit(-1);
  }

  begin = file.tellg();
  file.seekg(0, std::ios::end);
  end = file.tellg();
  size_t len = end - begin;

  if (s-&gt;verbose) LOG(INFO) &lt;&lt; &quot;len: &quot; &lt;&lt; len;

  std::vector&lt;uint8_t&gt; img_bytes(len);
  file.seekg(0, std::ios::beg);
  file.read(reinterpret_cast&lt;char*&gt;(img_bytes.data()), len);
</code></pre>
<h3 id="21split函数的实现"><strong>21.split函数的实现</strong></h3>
<pre><code class="language-cpp">std::vector&lt;std::string&gt; split(const std::string &amp;str, const std::string &amp;sep)
{
    std::string::size_type pos;
    std::vector&lt;std::string&gt; result;

    std::string newstr =  str + sep;
    size_t size=newstr.size();

    for(size_t i=0; i&lt;size; ++i)
    {
        pos=newstr.find(sep,i);
        if(pos&lt;size)
        {
            std::string s = newstr.substr(i,pos-i);
            result.push_back(s);
            i=pos+sep.size()-1;
        }
    }
    return result;
}
</code></pre>
<h3 id="20判断是否有宏定义"><strong>20.判断是否有宏定义</strong></h3>
<pre><code class="language-cpp">#ifdef PLATFORM_QNX  
  int platform = 1;
#elif defined PLATFORM_ANDROID
  int platform = 2;
#else
  int platform = 3;
#endif
</code></pre>
<h3 id="19不支持模版别名的处理办法"><strong>19.不支持模版别名的处理办法</strong></h3>
<p>__cpp_user_defined_literals测试，从gcc4.7版本开始支持模板别名，但是qnx的libc++的__config却检测到gcc就认为没有模板别名的特性</p>
<p>所以这里有个bug，是libc++库对gcc编译的配置选项出现了问题</p>
<p>参考标准库中libc++库中memory头文件中的一段代码</p>
<pre><code class="language-cpp">#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
    template &lt;class _Tp&gt; using rebind_alloc =
                  typename __allocator_traits_rebind&lt;allocator_type, _Tp&gt;::type;
    template &lt;class _Tp&gt; using rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Tp&gt;&gt;;
#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES
    template &lt;class _Tp&gt; struct rebind_alloc
        {typedef typename __allocator_traits_rebind&lt;allocator_type, _Tp&gt;::type other;};
    template &lt;class _Tp&gt; struct rebind_traits
        {typedef allocator_traits&lt;typename rebind_alloc&lt;_Tp&gt;::other&gt; other;};
#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES
</code></pre>
<h3 id="18libstdclibc"><strong>18.libstdc++/libc++</strong></h3>
<p>gcc配套的 <code>libstdc++</code>
<code>llvm/clang++</code> 配套的 <code>libc++</code></p>
<p><code>libstdc++</code>包含两个库: <code>libstdc++.so</code>(接口层) 和 <code>libsupc++.so</code>(实现层) 
<code>libc++</code>包含两个库: <code>libc++.so</code>(接口层) <code>libc++abi.so</code>(实现层)</p>
<p><code>libstdc++</code>的头文件位置 <code>/usr/include/c++/5.4/</code>  其中<code>5.4</code>位gcc编译器的版本号
<code>libc++</code>头文件的位置 <code>/usr/include/c++/v1/</code></p>
<p>配置编译选项:【注意】这个是配置选择头文件的
<code>-stdlib=libc++  -stdlib=libstdc++</code></p>
<p>通过cmake配置</p>
<pre><code class="language-cmake">set(CMAKE_EXE_LINKER_FLAGS &quot;${CMAKE_EXE_LINKER_FLAGS} -stdlib=libc++ -lc++ -lc++abi&quot;)
</code></pre>
<h3 id="17虚析构的作用"><strong>17.虚析构的作用</strong></h3>
<p>1.通过父类指针释放所指向的子类。</p>
<pre><code class="language-cpp">class Animal {
  vitual ~Animal() {
    std::cout &lt;&lt; &quot;delete animal..&quot; &lt;&lt; std::endl;
  }
}

class Dog : public Animal {
  ~Dog() {
    std::cout &lt;&lt; &quot;delete dog...&quot; &lt;&lt; std::endl;
  };
};

Animal* animal = new Dog();

delete animal;
</code></pre>
<p>如上执行会输出</p>
<pre><code class="language-text-plain">delete dog...
delete animal..
</code></pre>
<p>如果去掉了vitual修饰~Animal()，则会只输出如下</p>
<pre><code class="language-text-plain">delete animal..
</code></pre>
<p>因为父类的构造函数和析构函数不能被子类继承，但是会形成多态，</p>
<p>所以当父类定义成虚析构函数的时候，会先动态调用子类的析构函数，</p>
<p>然后由于delete的机制，会接着调用父类的析构函数</p>
<h3 id="16待查。。。"><strong>16.待查。。。</strong></h3>
<pre><code class="language-cpp">std::atomic_bool                             shutdownFlag_;
while (!shutdownFlag_.load(std::memory_order_acquire)) {

}
</code></pre>
<h3 id="15同名的头文件"><strong>15.同名的头文件</strong></h3>
<p>如果搜索路径中包含两个同名的头文件，这时候只会包含第一个搜索到的头文件。示例如下</p>
<pre><code class="language-text-plain">目录结构

cpptest
|
|---build
|
|---include_1
|   |
|   |---same_name.hpp
|
|---include_2
|   |
|   |---same_name.hpp
|
|---main.cpp
|
|---CMakeLists.txt
</code></pre>
<p><code>include_1/same_name.hpp</code> 中内容如下</p>
<pre><code class="language-cpp">struct cat{
  int age;
};
</code></pre>
<p><code>include_2/same_name.hpp</code> 中内容如下</p>
<pre><code class="language-cpp">struct dog{
  int age;
};
</code></pre>
<p><code>CMakeLists.txt</code>内容如下</p>
<pre><code class="language-cmake">project(demo)
set(CMAKE_CXX_STANDARD 11)

add_executable(
  ${PROJECT_NAME}
  main.cpp)

target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  include_2
  include_1
)
</code></pre>
<p><code>main.cpp</code>内容如下</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include &quot;same_name.hpp&quot;

int main(int argc, char* argv[]) {
  cat c;
  c.age = 1;
  dog d;
  d.age = 2;
  cout &lt;&lt; d.age &lt;&lt; endl;
}
</code></pre>
<p>这时候编译会报错如下</p>
<pre><code class="language-bash">/Users/liushichao/Exercise/cpp/test_cpp/main.cpp:6:3: error: unknown type name &#39;cat&#39;
</code></pre>
<p>调整<code>CMakeLists.txt</code>内容如下</p>
<pre><code class="language-cmake">project(demo)
set(CMAKE_CXX_STANDARD 11)

add_executable(
  ${PROJECT_NAME}
  main.cpp)

target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  include_1
  include_2
)
</code></pre>
<p>这时候编译会报错如下</p>
<pre><code class="language-bash">/Users/liushichao/Exercise/cpp/test_cpp/main.cpp:8:3: error: unknown type name &#39;dog&#39;
</code></pre>
<p>调整<code>CMakeLists.txt</code>内容如下</p>
<pre><code class="language-cmake">project(demo)
set(CMAKE_CXX_STANDARD 11)

add_executable(
  ${PROJECT_NAME}
  main.cpp)

target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
)
</code></pre>
<p><code>main.cpp</code>内容如下</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include &quot;include_1/same_name.hpp&quot;
#include &quot;include_2/same_name.hpp&quot;

int main(int argc, char* argv[]) {
  cat c;
  c.age = 1;
  dog d;
  d.age = 2;
  cout &lt;&lt; d.age &lt;&lt; endl;

}
</code></pre>
<p>这样就可以运行成功了。</p>
<h3 id="14可变参数数模板"><strong>14.可变参数数模板</strong></h3>
<p>1.递归展开参数包</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

std::string operator&quot;&quot;_s (const char* orign) {

  return  orign;
}

template &lt;typename T&gt;
T sum(T head) {
  return head;
}

template &lt;typename T, typename... Types&gt; 
T sum(T head, Types... args) {
  cout &lt;&lt; sizeof...(args) &lt;&lt; endl;
  return head + sum&lt;T&gt;(args...);
}

int main(int argc, char* argv[]) {
  cout &lt;&lt; sum(1, 2, 3, 4, 5) &lt;&lt; endl;
}
</code></pre>
<h3 id="13c操作符--operators"><strong>13.c++操作符 / operators</strong></h3>
<p>c++ 11 引入了新的操作夫，用户定义字面量操作符，<a href="https://en.cppreference.com/w/cpp/language/user_literal">https://en.cppreference.com/w/cpp/language/user_literal</a></p>
<p>C++ divides the operators into the following groups:</p>
<ul>
<li>Arithmetic operators</li>
<li>Assignment operators</li>
<li>Comparison operators</li>
<li>Logical operators</li>
<li>Bitwise operators</li>
</ul>
<h3 id="12cpp文件中编写模板的定义"><strong>12.cpp文件中编写模板的定义</strong></h3>
<p>参考：</p>
<p><a href="https://stackoverflow.com/a/115735">https://stackoverflow.com/a/115735</a></p>
<p><a href="https://www.codeproject.com/Articles/48575/How-to-Define-a-Template-Class-in-a-h-File-and-Imp">https://www.codeproject.com/Articles/48575/How-to-Define-a-Template-Class-in-a-h-File-and-Imp</a></p>
<pre><code class="language-cpp">//mstack.hpp
template&lt;typename T&gt;
class mstack{
 void push(const T&amp; e);
};
</code></pre>
<pre><code class="language-cpp">//mstack.cpp
template&lt;typename T&gt;
void mstack&lt;T&gt;::push(const T&amp; e) {
 data_.push_back(e);
}

//important!!!
// this func is no need to be call.
void testxxx() {
 mstack&lt;int&gt; ms;
 ms.push(1);
}
</code></pre>
<pre><code class="language-cpp">//client.cpp

void main() {
 mstack&lt;int&gt; m_c_s;
 m_c_s.push(2334);
}
</code></pre>
<h3 id="11类中的const成员函数"><strong>11.类中的const成员函数</strong></h3>
<p>参考： c++ primer 5 中文版 p231</p>
<p>成员函数的参数列表后面紧跟的const关键字是修饰隐式的this指针的。是顶层指针（参考下边的10顶层const的介绍），表明this是指向常量对象的，const成员函数中的 this 指向的值不能修改。const 的对象上不能调用非const成员函数，所以定义成const的成员函数调用起来更灵活。</p>
<h3 id="10顶层const与底层const"><strong>10.顶层const与底层const</strong></h3>
<p>参考：c++ primer 5 中文版 p57</p>
<p>这个是针对指针的，因为指针本身也是对象，所以const修饰指针的变量的时候可能产生歧义，一个是指针变量是常量不可变，另一种情况是指针指向的是常量，这样指针变量本身是可以修改的。</p>
<p>为了区分这两种情况，引入了顶层const和底层const两种类型，</p>
<pre><code class="language-text-plain"> p  &lt;--- p是指向i的指针，如果p是const的话，就叫顶层const，顶层const的写法   int* const p = i; ,const 直接修饰的p，
 
 |
 v

 i  &lt;--- 如果i 是const的话，就是底层const， 底层const的写法 ： const int * p = i; ,const 直接修饰的是int，代表指向的是常量的int类型

</code></pre>
<h3 id="9stdunordered_map-查找指定key是否存在"><strong>9.std::unordered_map 查找指定key是否存在</strong></h3>
<p>使用<code>count(key)</code>方法，如果key存在，返回1，如果不存在，返回0</p>
<h3 id="8stdmap有序"><strong>8.std::map有序</strong></h3>
<p>std::map是有序的，但是不是插入的顺序，而是按照key的值进行排序的，默认是从小到大排序，可以通过模版参数的第三个参数指定排序类型</p>
<h3 id="7c计时"><strong>7.c++计时</strong></h3>
<pre><code class="language-cpp">1.包含头文件
#include &lt;chrono&gt;

2.计时开始位置添加
std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; time_begin = std::chrono::high_resolution_clock::now();

3.计时结束位置添加
long long eclipse_time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now() - time_begin).count();
          
4.eclipse_time即为统计的时间，单位是ms
</code></pre>
<h3 id="6各种类型的最大最小值宏定义"><strong>6.各种类型的最大最小值宏定义</strong></h3>
<p>包含头文件</p>
<pre><code class="language-cpp">#include &lt;float.h&gt;  //double float 需要用到这个
#include &lt;limits.h&gt; //int longlong long 需要用这个
</code></pre>
<p>下边是具体的最大最小值的宏定义</p>
<pre><code class="language-cpp">int   n1　=　INT_MIN;
int   n2　=　INT_MAX;
float　f1　=　FLT_MIN;
float　f2　=　FLT_MAX;
double　d1　=　DBL_MIN;
double　d2　=　DBL_MAX;
long ln1 =  LONG_MAX;
long ln2 =  LONG_MIN;
long long lln1 = LONG_LONG_MAX;
long long lln1 = LONG_LONG_MIN;
</code></pre>
<h3 id="5condition_variable"><strong>5.condition_variable</strong></h3>
<p>wait_for可以指定等待时间，用来实现定时器效果</p>
<p>下边的代码，可以通过condition.signal()来唤醒阻塞的线程，其他时候会到一秒钟自动唤醒，但是这种可能会有假唤醒的时候，如果要避免假唤醒，可以再传递一个函数，返回bool类型。</p>
<pre><code class="language-cpp">std::unique_lock&lt;std::mutex&gt; sleep_lock(mutex_);
condition.wait_for(sleep_lock, std::chrono::milliseconds(1000));
</code></pre>
<h3 id="4运算符优先级"><strong>4.运算符优先级</strong></h3>
<pre><code class="language-text-plain">
*乘 /除

+加 -减

&gt;大于 &lt;小于

==等于 !=不等于

&amp;&amp;与 

||或
</code></pre>
<h3 id="3stdunique_lock-与-stdlock_guard的区别"><strong>3.std::unique_lock 与 std::lock_guard的区别</strong></h3>
<p>unique_lock可以随时释放锁，调用unlock()</p>
<p>lock_guard需要等到生命周期结束后，才能自动释放锁。</p>
<pre><code class="language-cpp">用法示例：
    {
        std::unique_lock&lt;std::mutex&gt; lock_get_lane_data(mutex_lan_date_msg_);
        //lock_get_lane_data.unlock();
    }
</code></pre>
<h3 id="将double转换成string时保留15位小数"><strong>将double转换成string时保留15位小数</strong></h3>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;sstream&gt;

double ceshi = std::stod(&quot;3.123456789&quot;);
stringstream ss;
ss &lt;&lt; std::setprecision(15) &lt;&lt; ceshi;
std::string ceshi_str = ss.str();
cout &lt;&lt; ceshi_str &lt;&lt;endl;
</code></pre>
<p>java中</p>
<pre><code class="language-text-plain">其中String s=String.format(&quot;%.2f&quot;,d)表示小数点后任意两位小数，其中2为表示两位小数，若需要三位小数，把2改为3即可，其他同理。
</code></pre>
<p>c++ primer 5th p600</p>
<h3 id="使用ms后缀"><strong>使用ms后缀</strong></h3>
<pre><code class="language-cpp">#include &lt;chrono&gt;
using namespace std::chrono_literals;
</code></pre>
<h3 id="使用sstream输出-unsigned-char存储的数字"><strong>使用sstream输出 unsigned char存储的数字</strong></h3>
<p>为了节省存储空间，经常会用usigned char来存储一些数值范围比较小的数字，当用ostringstream转换成string时会出现问题，举例如下</p>
<pre><code class="language-cpp">unsinged char a = 10;
std::ostringstream oss;
oss &lt;&lt; a;
cout &lt;&lt; oss.str(); //输出换行
</code></pre>
<p>这里标准输出打印的并不是“10”，而是会换行，因为a的类型是char，所以会把a的值作为ascii码的值，转换成string，要想输出“10”，需要强转a成int类型</p>
<pre><code class="language-cpp">unsinged char a = 10;
std::ostringstream oss;
oss &lt;&lt; (int)a;
cout &lt;&lt; oss.str(); //输出10
</code></pre>
<h2 id="opencv">OpenCV</h2>
<h3 id="3本地cmake加入opencv库"><strong>3.本地cmake加入opencv库</strong></h3>
<pre><code class="language-cmake">find_package(OpenCV REQUIRED)  #注意大小写
target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  ${OpenCV_INCLUDE_DIRS}
)

target_link_libraries(
  ${PROJECT_NAME}
  ${OpenCV_LIBS}
)
</code></pre>
<h3 id="2编译安卓ndk库"><strong>2.编译安卓ndk库</strong></h3>
<p>从github下载源码，进入到源码跟目录，创建build文件夹，进入build文件夹，执行下边的编译指令</p>
<pre><code class="language-sh">export ANDROID_NDK=/Users/liushichao/Library/Android/sdk/ndk/21.0.6113669
export ANDROID_ABI=armeabi-v7a
export ANDROID_NATIVE_API_LEVEL=android-28
export ANDROID_TOOLCHAIN_NAME=arm-linux-androideabi-clang

cmake			       \
  -DANDROID_NDK=${ANDROID_NDK} \
  -DANDROID_ABI=${ANDROID_ABI} \
  -DANDROID_STL=c++_shared  \
  -DANDROID_NATIVE_API_LEVEL=${ANDROID_NATIVE_API_LEVEL} \
  -DBUILD_SHARED_LIBS=1 \
  -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \
  -DANDROID_TOOLCHAIN_NAME=${ANDROID_TOOLCHAIN_NAME} \
  -D BUILD_opencv_java=ON \
  -D BUILD_ANDROID_PROJECTS=ON \
        -D WITH_CUDA=OFF \
        -D WITH_MATLAB=OFF \
        -D BUILD_ANDROID_EXAMPLES=OFF \
        -D BUILD_DOCS=OFF \
        -D CMAKE_BUILD_TYPE=Release \
        -D BUILD_PERF_TESTS=OFF \
        -D BUILD_TESTS=OFF \
        -DCMAKE_INSTALL_PREFIX=&quot;/Users/liushichao/source/opencv/install_ndk&quot; \
  ..

make -j8
make install
</code></pre>
<h3 id="1注意cvmat的宽高参数"><strong>1.注意cv::Mat()的宽高参数</strong></h3>
<p>前边是高，后边是宽，不要弄反了</p>
<pre><code class="language-cpp">Mat (int rows, int cols, int type);
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>CMake</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/cmake/"/>
        <id>https://liushuya7.github.io/wiki/cmake/</id>
            <category term="CMake"/>
            <category term="C++"/>

        <updated>2022-12-13T13:23:15-05:00</updated>
            <summary>
                <![CDATA[
                    CMake Reference/Tutorial Step 2: Adding a Library Step 3: Adding Usage Requirements for a Library Step 4: Installing and Testing Step 9: Selecting Static or&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="cmake-referencetutorial"><a href="https://cmake.org/cmake/help/latest/index.html#">CMake Reference/Tutorial</a></h2>
<ul>
<li><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20a%20Library.html">Step 2: Adding a Library</a></p>
</li>
<li><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20Usage%20Requirements%20for%20a%20Library.html">Step 3: Adding Usage Requirements for a Library</a></p>
</li>
<li><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Installing%20and%20Testing.html">Step 4: Installing and Testing</a></p>
<ul>
<li><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Installing%20and%20Testing.html#install-rules">Install Rules</a></li>
</ul>
</li>
<li><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Selecting%20Static%20or%20Shared%20Libraries.html">Step 9: Selecting Static or Shared Libraries</a></p>
</li>
<li><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20Generator%20Expressions.html">Step 10: Adding Generator Expressions</a></p>
</li>
<li><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Adding%20Export%20Configuration.html">Step 11: Adding Export Configuration</a></p>
</li>
<li><p><a href="https://cmake.org/cmake/help/latest/guide/tutorial/Packaging%20Debug%20and%20Release.html">Step 12: Packaging Debug and Release</a></p>
</li>
<li><p><a href="https://stackoverflow.com/a/68734757">CMake Suggestions on Stackoverflow</a></p>
</li>
</ul>
<h3 id="1-指定第三方库的查找路径"><strong>1. 指定第三方库的查找路径</strong></h3>
<p>可以使用<code>CMAKE_PREFIX_PATH</code>变量指定第三方库的查找路径（指定的安装路径）</p>
<pre><code class="language-text-x-sh">cd build
cmake -DCMAKE_PREFIX_PATH=/Users/josh/my_install_dir ..
make
# OR
cmake --install . --prefix ${PATH_TO_INSTALL}
</code></pre>
<h3 id="2-在源文件中检查某个符号是否是函数变量宏定义-checksymbolexists"><strong>2. 在源文件中检查某个符号是否是函数/变量/宏定义</strong> <a href="https://cmake.org/cmake/help/latest/module/CheckSymbolExists.html"><strong>CheckSymbolExists</strong></a></h3>
<pre><code class="language-text-plain">在c中用
CheckSymbolExists 
在cpp中用
CheckCXXSymbolExists
</code></pre>
<h3 id="3-add_subdirectory用法"><strong>3. add_subdirectory用法</strong></h3>
<p>直接指定要链接的子目录文件夹的相对路径即可，但是还要自己指定头文件</p>
<pre><code class="language-text-x-cmake">add_subdirectory(
  lib/sgmnv_tool
)

target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  lib/sgmnv_tool/include
)

target_link_libraries(
  ${PROJECT_NAME}
  sgmnv_tool
)
</code></pre>
<h3 id="4-target_link_directories"><strong>4. target_link_directories</strong></h3>
<p>可以配置库文件的查找目录，跟target_include_directories的效果类似</p>
<pre><code class="language-text-x-cmake">target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  src/
  src/rpc
  src/protobuf/
  src/grpcs/
  ${OpenCV_INCLUDE_DIRS}
  lib/sgmnv_tool/include
)

target_link_libraries(
  ${PROJECT_NAME}
  protobuf::libprotobuf
  gRPC::grpc++_reflection
  gRPC::grpc++
  ${OpenCV_LIBS}
  # sgmnv_tool
)
</code></pre>
<h3 id="5-file命令"><strong>5. file命令</strong></h3>
<p>file命令可以使用通配符表达式方便的获取某一个文件夹下的全部源文件，例如</p>
<pre><code class="language-text-plain">file(GLOB_RECURSE GRPC_SOURCES_FILE
  src/protobuf/*.cc
  src/rpc/*.cc
)

add_library(
  ${PROJECT_NAME}
  SHARED
  ${GRPC_SOURCES_FILE})
</code></pre>
<h3 id="6-make打印过程中的信息"><strong>6. make打印过程中的信息</strong></h3>
<pre><code class="language-text-plain">make VERBOSE=1
</code></pre>
<h3 id="7-generator-expression"><strong>7. generator expression</strong></h3>
<p>参考链接： <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#string-valued-generator-expressions">https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#string-valued-generator-expressions</a></p>
<p>表达式的样式 <code>$&lt;...&gt;</code></p>
<p>调试方法</p>
<p>因为生成表达式是在编译阶段生成的，不是在执行cmake阶段生成的，所以不能用message显示，可以用下边的方法显示</p>
<pre><code class="language-text-plain">add_custom_target(genexdebug COMMAND ${CMAKE_COMMAND} -E echo &quot;$&lt;...&gt;&quot;)
或者
file(GENERATE OUTPUT filename CONTENT &quot;$&lt;...&gt;&quot;)
</code></pre>
<h3 id="8-cache"><strong>8. cache</strong></h3>
<p>作用：缓存变量的值，在整个项目的的编译中都可以读取，一次缓存，多次编译都能读取，这个是存在build目录下CMakeCache.txt文件中的</p>
<p>通过set命令可以设置缓存，如果不加FORCE选项的话不会覆盖之前的值</p>
<pre><code class="language-text-plain">  set(my_cache &quot;lala&quot; CACHE STRING &quot;test cmake cache.&quot; FORCE)
</code></pre>
<p>通过unset可以删除这个缓存变量</p>
<pre><code class="language-text-plain">unset(my_cache CACHE)
</code></pre>
<h3 id="9-find_package"><strong>9. find_package()</strong></h3>
<p>作用：查找已经安装的包，首先在<code>${CMAKE_MODULE_PATH}</code>中查找，Findxxx.cmake，然后在<code>&lt;CMAKE_ROOT&gt;/share/cmake-x.y/Modules/</code>中查找Findxxx.cmake，如果这两个文件中都找不到Findxxx.cmake，则查找xxxConfig.cmake 或者xxx-config.cmake。</p>
<p>设置查找文件夹路径</p>
<pre><code class="language-text-plain">set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} &quot;${CMAKE_SOURCE_DIR}/cmake/Modules/&quot;)
</code></pre>
<p>找到后，会设置以下几个变量</p>
<pre><code class="language-text-plain">xxx_FOUND
xxx_INCLUDE_DIRS or _INCLUDES
xxx_LIBRARIES or _LIBRARIES or _LIBS
xxx_DEFINITIONS
</code></pre>
<h3 id="9-add_definitions"><strong>9. add_definitions</strong></h3>
<p>作用：在原文件中定义指定的宏，示例如下</p>
<pre><code class="language-text-plain">OPTION(USE_MACRO
  &quot;Build the project using macro&quot;
  OFF)

if(USE_MACRO)

 add_definitions(&quot;-DUSE_MACRO&quot;)

endif(USE_MACRO)
</code></pre>
<p>使用时</p>
<pre><code class="language-text-plain">开启：　cmake 　-DUSE_MACRO＝ON ..

关闭：　cmake 　-DUSE_MACRO＝OFF ..
</code></pre>
<h3 id="10-target_compile_definitions"><strong>10. target_compile_definitions</strong></h3>
<p>作用：#define xxxxx zzzz</p>
<p>用法：</p>
<pre><code class="language-text-plain">target_compile_definitions(hello PUBLIC MY_DEFINE=&quot;nihao&quot;)
</code></pre>
<p>如果在编译的main.cpp中，写入如下代码的话</p>
<pre><code class="language-text-plain">int main()
{
#ifdef MY_DEFINE
  cout&lt;&lt; MY_DEFINE &lt;&lt; endl;
#else
  cout &lt;&lt; &quot;undefine&quot; &lt;&lt; endl;
#endif
  return 0;
}
</code></pre>
<p>会输出 <code>nihao</code></p>
<h3 id="11-指定编译release版本或debug版本"><strong>11. 指定编译release版本或debug版本</strong></h3>
<p>注意：如果不使用<code>CMAKE_BUILD_TYPE</code>参数，则默认是Debug</p>
<pre><code class="language-text-plain">-DCMAKE_BUILD_TYPE=Debug
# OR
-DCMAKE_BUILD_TYPE=Release
</code></pre>
<p>指定好<code>CMAKE_BUILD_TYPE</code>后，还要指定<code>CMAKE_CXX_FLAGS_RELEASE</code>或者<code>CMAKE_CXX_FLAGS_DEBUG</code></p>
<pre><code class="language-text-plain"># 设置Release版本的编译选项
SET(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV{CXXFLAGS} -O3 -Wall&quot;)
# 设置Debug版本的编译选项
SET(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV{CXXFLAGS} -O0 -g -Wall&quot;)
</code></pre>
<p>例子：</p>
<pre><code class="language-text-plain">mkdir Release  
cd Release  
cmake -DCMAKE_BUILD_TYPE=Release ..  
make 
</code></pre>
<pre><code class="language-text-plain">mkdir Debug  
cd Debug  
cmake -DCMAKE_BUILD_TYPE=Debug ..  
make  
</code></pre>
<h3 id="12-message"><strong>12. MESSAGE</strong></h3>
<p>有些情况下需要指定消息的错误等级才能显示出来这个消息，用来调试用，例如</p>
<pre><code class="language-text-plain">  message(FATAL_ERROR
        &quot;The RMW implementation has been specified as &quot;
        &quot;&#39;${requested_rmw_implementation}&#39; &quot;
        &quot;through the environment variable &#39;RMW_IMPLEMENTATION&#39;, &quot;
        &quot;however this needs to match the RMW implementation &quot;
        &quot;&#39;${default_rmw_implementation}&#39;, &quot;
        &quot;which was specified when the &#39;rmw_implementation&#39; package was built.&quot;)
</code></pre>
<p>以下是全部的等级 参考链接： <a href="https://cmake.org/cmake/help/latest/command/message.html">https://cmake.org/cmake/help/latest/command/message.html</a></p>
<pre><code class="language-text-plain">FATAL_ERROR
CMake Error, stop processing and generation.

SEND_ERROR
CMake Error, continue processing, but skip generation.

WARNING
CMake Warning, continue processing.

AUTHOR_WARNING
CMake Warning (dev), continue processing.

DEPRECATION
CMake Deprecation Error or Warning if variable CMAKE_ERROR_DEPRECATED or CMAKE_WARN_DEPRECATED is enabled, respectively, else no message.

(none) or NOTICE
Important message printed to stderr to attract user’s attention.

STATUS
The main interesting messages that project users might be interested in. Ideally these should be concise, no more than a single line, but still informative.

VERBOSE
Detailed informational messages intended for project users. These messages should provide additional details that won’t be of interest in most cases, but which may be useful to those building the project when they want deeper insight into what’s happening.

DEBUG
Detailed informational messages intended for developers working on the project itself as opposed to users who just want to build it. These messages will not typically be of interest to other users building the project and will often be closely related to internal implementation details.

TRACE
Fine-grained messages with very low-level implementation details. Messages using this log level would normally only be temporary and would expect to be removed before releasing the project, packaging up the files, etc.
</code></pre>
<h3 id="13-file命令（神器）"><strong>13. file命令（神器）</strong></h3>
<p>下边命令能将opencv的全部库文件都添加到link中</p>
<pre><code class="language-text-plain">file(GLOB_RECURSE dyso &quot;/Users/liushichao/Exercise/build_opencv_4.3.0/lib/*.dylib&quot;)
target_link_libraries(test_sort
${dyso}
)
MESSAGE(&quot;${dyso}&quot;)
</code></pre>
<h3 id="14-if语句"><strong>14. if语句</strong></h3>
<p>执行<code>cmake -DUSER_DEFINE=dadah ./</code>，返回”err”.</p>
<pre><code class="language-text-plain">if(NOT &quot;${USER_DEFINE}&quot; STREQUAL &quot;dadah&quot;)
  MESSAGE(&quot;ok.&quot;)
else()
  MESSAGE(&quot;err.&quot;)
endif()
</code></pre>
<h3 id="15-get_filename_component"><strong>15. get_filename_component</strong></h3>
<p>获取第二个参数的绝对路径，存到第一个参数重，执行完后 <code>ANDROID_NDK_EXPECTED_PATH</code> 中存储的事当前路径的绝对路径</p>
<pre><code class="language-text-plain">get_filename_component(ANDROID_NDK_EXPECTED_PATH
    &quot;./&quot; ABSOLUTE)
</code></pre>
<h3 id="16-使用环境变量"><strong>16. 使用环境变量</strong></h3>
<p><code>$ENV{xxx}</code>可以获取环境变量<code>xxx</code></p>
<pre><code class="language-text-plain">MESSAGE(&quot;$ENV{PATH}&quot;)
</code></pre>
<h3 id="17-cmake路径"><strong>17. cmake路径</strong></h3>
<p>为了统一路径中的分割符windows <code>c:\xx</code> linux <code>/usr/xxx</code>，cmake定义了统一的分割符<code>/</code>的路径表示方式，可以用file命令进行转换</p>
<pre><code class="language-text-plain">file(TO_CMAKE_PATH &quot;&lt;path&gt;&quot; &lt;variable&gt;)
file(TO_NATIVE_PATH &quot;&lt;path&gt;&quot; &lt;variable&gt;)
</code></pre>
<h3 id="18-指定c标准库版本"><strong>18. 指定c++标准库版本</strong></h3>
<pre><code class="language-text-plain">cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
</code></pre>
<h3 id="19-include命令"><strong>19. include命令</strong></h3>
<p>通过定义xxx.cmake，可以重用cmake的代码 可以指定包含的文件的全路径，或者让cmake去搜索，搜索顺序：1. CMAKE_MODULE_PATH变量指定的路径 2. cmake自己的Modules文件夹<code>/usr/local/Cellar/cmake/3.18.1/share/cmake/Modules</code></p>
<pre><code class="language-text-plain">include(xxx.cmake)
</code></pre>
<h3 id="20-find_path"><strong>20. find_path()</strong></h3>
<p>在<code>/Users/liushichao/workspace</code>下创建<code>1.txt</code>,执行下边代码，返回<code>/Users/josh/workspace</code>。 如果没有找到，返回<code>TXT_PATH-NOTFOUND</code> 这个TXT_PATH如果被设置后，以后不会被更新</p>
<pre><code class="language-text-plain">find_path(TXT_PATH &quot;1.txt&quot; /Users/josh/workspace/123 /Users/josh/workspace)
MESSAGE(&quot;${TXT_PATH}&quot;)
</code></pre>
<h3 id="21-configure_file"><strong>21. configure_file</strong></h3>
<p>将输入文件，转换成输出文件，可以自定义变量，改变输出文件中的值 例如在cmakelist文件夹下定义一个foo.h.in文件，或者在其他目录里创建，然后cmakelist.txt文件中指明相对路径 在foo.h.in中可以加入如下定义</p>
<pre><code class="language-text-plain">//foo.h.in

#cmakedefine XXXX &quot;@XXXX@&quot;
@bbb@
</code></pre>
<p>编辑CMakeLists.txt</p>
<pre><code class="language-text-plain">//CMakeLists.txt

set(bbb &quot;nihao&quot;)
set(XXXX &quot;hahah&quot;)
configure_file(foo.h.in foo.h @ONLY)
</code></pre>
<p>会在执行cmake命令的目录里生成foo.h文件，内容如下</p>
<pre><code class="language-text-plain">//foo.h

#define XXXX &quot;hahah&quot;
nihao
</code></pre>
<p>如果CMakeLists.txt文件中没有写set(bbb “nihao”) 也没写 set(XXXX “hahah”)，则生成的文件如下</p>
<pre><code class="language-text-plain">//foo.h

/* #undef XXXX */
</code></pre>
<h3 id="22-cmake的function"><strong>22. cmake的function</strong></h3>
<p>定义如下，第一个参数是函数名，第二个参数是传入的参数</p>
<pre><code class="language-text-plain">function(func_name list)
  MESSAGE(&quot;${list}&quot;) #abc
  MESSAGE(&quot;${${list}}&quot;) #a;b;c
endfunction()
</code></pre>
<p>调用方法如下</p>
<pre><code class="language-text-plain">set(abc a b c)
func_name(abc)
</code></pre>
<p>输出</p>
<pre><code class="language-text-plain">abc
a;b;c
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Motion Planning</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/motion-planning/"/>
        <id>https://liushuya7.github.io/wiki/motion-planning/</id>
            <category term="ROS2"/>

        <updated>2022-12-13T13:11:46-05:00</updated>
            <summary>
                <![CDATA[
                    Tesseract Robotics | Optimization Motion Planning Tesseract wiki — Industrial Training documentation Optimal Control for Robotics
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <ul>
<li><p><a href="https://github.com/tesseract-robotics">Tesseract Robotics | Optimization Motion Planning</a></p>
</li>
<li><p><a href="https://ros-industrial-tesseract.readthedocs.io/en/latest/">Tesseract wiki — Industrial Training documentation</a></p>
</li>
<li><p><a href="https://towardsdatascience.com/optimal-control-for-robotics-part-1-4cc4ee5fb14d">Optimal Control for Robotics</a></p>
</li>
</ul>

            ]]>
        </content>
    </entry>
    <entry>
        <title>RTOS</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/rtos/"/>
        <id>https://liushuya7.github.io/wiki/rtos/</id>
            <category term="ROS2"/>

        <updated>2022-12-13T13:08:18-05:00</updated>
            <summary>
                <![CDATA[
                    FreeRTOS RTOS Basics: Getting Started with Microcontrollers Comparison between RTOSes Introduction to RTOS (Youtube Playlist) eProsima: RTPS/DDS Experts, the middleware experts BriscoeTech/Arduino-FreeRTOS-SAMD51: A port of&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="freertos"><a href="https://www.freertos.org/">FreeRTOS</a></h2>
<ul>
<li><p><a href="https://www.seeedstudio.com/blog/2021/04/26/rtos-basics-getting-started-with-microcontrollers/">RTOS Basics: Getting Started with Microcontrollers</a></p>
</li>
<li><p><a href="https://micro.ros.org/docs/concepts/rtos/comparison/">Comparison between RTOSes</a></p>
</li>
<li><p><a href="https://www.youtube.com/playlist?list=PLEBQazB0HUyQ4hAPU1cJED6t3DU0h34bz">Introduction to RTOS (Youtube Playlist)</a></p>
</li>
<li><p><a href="https://www.eprosima.com/">eProsima: RTPS/DDS Experts</a>, the middleware experts</p>
</li>
<li><p><a href="https://github.com/BriscoeTech/Arduino-FreeRTOS-SAMD51">BriscoeTech/Arduino-FreeRTOS-SAMD51: A port of FreeRTOS that runs on Arduino Samd51 boards</a></p>
<ul>
<li><a href="https://www.arduino.cc/reference/en/libraries/freertos_samd51/">FreeRTOS_SAMD51 - Arduino Reference</a></li>
</ul>
</li>
<li><p><a href="https://github.com/Rybec/pyRTOS#pyrtos-api">Rybec/pyRTOS: RTOS written in pure Python, designed for use with CircuitPython</a></p>
</li>
<li><p><a href="https://github.com/ROBOTIS-GIT/ros2arduino">ROBOTIS-GIT/ros2arduino: This library helps the Arduino board communicate with the ROS2 using XRCE-DDS.</a></p>
</li>
<li><p><a href="https://github.com/micro-ROS/freertos_apps">micro-ROS/freertos_apps: Sample applications for FreeRTOS + micro-ROS</a></p>
</li>
<li><p><a href="https://www.freertos.org/2020/09/micro-ros-on-freertos.html">micro-ROS on FreeRTOS</a></p>
</li>
<li><p><a href="https://docs.zephyrproject.org/latest/boards/arm/adafruit_trinket_m0/doc/index.html">Adafruit Trinket M0 — Zephyr Project Documentation</a></p>
</li>
<li><p><a href="https://github.com/Seeed-Studio?language=arduino">Seeed Studio</a> Github</p>
</li>
</ul>
<h2 id="armmbed">ARMmbed</h2>
<ul>
<li><a href="https://github.com/ARMmbed/mbed-os">ARMmbed/mbed-os: Arm Mbed OS is a platform operating system designed for the internet of things</a></li>
<li><a href="https://github.com/mROS-base/mros2">mROS-base/mros2: agent-less and lightweight communication library compatible with rclcpp for embedded devices</a></li>
<li><a href="https://github.com/mROS-base/mros2-mbed">mROS-base/mros2-mbed</a></li>
<li><a href="https://github.com/embedded-software-laboratory">i11, RWTH Aachen</a></li>
</ul>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Migrating from ROS1</title>
        <author>
            <name>Joshua Liu</name>
        </author>
        <link href="https://liushuya7.github.io/wiki/migrating-from-ros1/"/>
        <id>https://liushuya7.github.io/wiki/migrating-from-ros1/</id>
            <category term="ROS2"/>

        <updated>2022-12-13T12:59:54-05:00</updated>
            <summary>
                <![CDATA[
                    How-to: build ros-noetic on Ubuntu 22.04 set(CMAKE_CXX_STANDARD 14) find_package(ament_cmake REQUIRED) find_package(component1 REQUIRED) # ... find_package(componentN REQUIRED) # At the bottom of the file: ament_package() Code&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><a href="https://wikis.nyu.edu/display/ARPL/How-to%3A+build+ros-noetic+on+Ubuntu+22.04">How-to: build ros-noetic on Ubuntu 22.04</a></p>
<h3 id="package-manifests">Package manifests</h3>
<h3 id="cmakeliststxt">CMakeLists.txt</h3>
<ul>
<li>Start by enabling C++14</li>
</ul>
<pre><code class="language-cmake">set(CMAKE_CXX_STANDARD 14)

find_package(ament_cmake REQUIRED)
find_package(component1 REQUIRED)
# ...
find_package(componentN REQUIRED)


# At the bottom of the file:
ament_package()
</code></pre>
<h3 id="code">Code</h3>
<ul>
<li><a href="https://docs.ros2.org/galactic/api/geometry_msgs/index-msg.html">geometry_msgs</a>/msg/TransformStamped.msg<ul>
<li>ROS1 <code>#include &lt;geometry_msgs/TransformStamped.h&gt;</code></li>
<li>ROS2 <code>#include &lt;geometry_msgs/msg/transform_stamped.hpp&gt;</code><ul>
<li>When defining customized *.msg, should not use <code>CamelCase</code>, rather, should use <code>camel_case</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>

            ]]>
        </content>
    </entry>
</feed>
